import os
import shutil
import zipfile
import re

def get_plugin_version(init_file_path):
    """从 __init__.py 中读取插件版本"""
    try:
        with open(init_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            # 匹配 version: (X, Y, Z) 这样的格式
            match = re.search(r'"version":\s*\(([^,]+),\s*([^,]+),\s*([^)]+)\)', content)
            if match:
                # 移除可能的空格，并用点连接
                return f"{match.group(1).strip()}.{match.group(2).strip()}.{match.group(3).strip()}"
    except FileNotFoundError:
        print(f"Warning: __init__.py not found at {init_file_path}. Using default version.")
    return "0.0.0" # 默认版本

def build_release():
    project_root = os.path.dirname(os.path.abspath(__file__))

    # --- 关键修改部分 ---
    # 定义你的项目基本名称，用于zip文件名 (例如: L4D2_Character_Tools)
    project_base_name = "L4D2_Character_Tools" # <-- 请根据你的实际项目名称修改

    # 定义Blender插件安装时所需的内部文件夹名称 (例如: blender_l4d2_tools)
    # 这个名称是Blender解压zip后，期望在addons目录下看到的文件夹名
    # 通常是你的 __init__.py 文件所在的目录名
    blender_addon_folder_name = "L4D2_Character_Tools" # <-- 请根据你的插件实际名称修改
                                                    # 如果你的所有py文件和resources都在根目录，
                                                    # 那么这个就是zip解压后，Blender会识别的插件文件夹名。
                                                    # 比如，如果根目录就是插件目录，可以设为 L4D2_Character_Tools
                                                    # 但更常见的是，根目录里有一个子目录是插件本身。
                                                    # 根据你的截图，你的所有.py文件和resources都在根目录，
                                                    # 所以这个 `blender_addon_folder_name` 应该就是你希望Blender安装后看到的顶层文件夹名。
                                                    # 比如，你希望用户安装后，addons里出现一个叫做 `L4D2_Character_Tools` 的文件夹，
                                                    # 里面包含所有的.py文件和resources。
                                                    # 那么 `blender_addon_folder_name` 就应该是 "L4D2_Character_Tools"
    # --- 关键修改部分结束 ---

    # 定义需要包含在发布包中的文件和目录（相对于项目根目录）
    include_files_and_dirs = [
        'resources',
        'bone_dict.py',
        'flex_dict.py',
        'flexmix_presets.py',
        'jiggleparams_presets.py',
        'presets',
        '__init__.py',
        'bone_modify.py',
        'flex.py',
        'jigglebone.py',
        'translation.py',
        'updatelog.txt',
        'vrd.py',
        'weights.py',
        # 'LICENSE', # 如果你决定包含 LICENSE，可以在这里添加
    ]

    # 获取版本号 (从 __init__.py 读取)
    version = get_plugin_version(os.path.join(project_root, '__init__.py'))
    
    # 构造最终的zip文件名
    zip_filename = f"{project_base_name}-v{version}.zip"

    # 创建一个临时目录用于构建发布包
    build_dir = os.path.join(project_root, "release_build")
    # 这个是最终会被压缩成zip的目录，即用户安装后Blender会解压出来的目录
    temp_plugin_root_in_build = os.path.join(build_dir, blender_addon_folder_name)

    # 清理旧的构建目录
    if os.path.exists(build_dir):
        shutil.rmtree(build_dir)
    os.makedirs(temp_plugin_root_in_build, exist_ok=True)

    print(f"Preparing files for {blender_addon_folder_name} v{version}...")

    # 复制指定的文件和目录到临时插件根目录
    for item_name in include_files_and_dirs:
        source_path = os.path.join(project_root, item_name)
        destination_path = os.path.join(temp_plugin_root_in_build, item_name)

        if not os.path.exists(source_path):
            print(f"Warning: Source item '{item_name}' not found. Skipping.")
            continue

        if os.path.isdir(source_path):
            shutil.copytree(source_path, destination_path, symlinks=False)
            print(f"  Copied directory: {item_name}/")
        else:
            shutil.copy2(source_path, destination_path)
            print(f"  Copied file: {item_name}")

    final_zip_path = os.path.join(project_root, zip_filename)

    print(f"Creating zip archive: {final_zip_path}...")
    with zipfile.ZipFile(final_zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        # 遍历临时插件根目录，将其内容添加到zip文件中
        # 确保zip文件内部的结构是 blender_addon_folder_name/file or blender_addon_folder_name/subdir/file
        for root, dirs, files in os.walk(temp_plugin_root_in_build):
            for file in files:
                file_path = os.path.join(root, file)
                # 计算在zip文件中的相对路径，例如 'blender_addon_folder_name/bone_dict.py'
                arcname = os.path.relpath(file_path, build_dir)
                zipf.write(file_path, arcname)
            # 对于空目录，zipfile不会自动添加，如果需要保留，可以手动添加
            for dir_name in dirs:
                dir_path = os.path.join(root, dir_name)
                # 计算在zip文件中的相对路径
                arcname = os.path.relpath(dir_path, build_dir)
                if not os.listdir(dir_path): # 如果是空目录，需要显式添加
                    zipf.writestr(arcname + '/', '') # 注意这里加 '/'

    print(f"Cleaning up temporary build directory: {build_dir}...")
    shutil.rmtree(build_dir)

    print(f"Successfully created release package: {final_zip_path}")

if __name__ == "__main__":
    build_release()
